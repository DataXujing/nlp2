<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Embadding - NLP-2</title>
  

  <link rel="shortcut icon" href="../icon.ico">
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Embadding";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> NLP-2</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">主页</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../chapter1/">TF-IDF</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Embadding</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#1nlprepresentation">1.NLP的核心关键：语言表示（Representation）</a></li>
                
            
                <li class="toctree-l3"><a href="#2nlp">2.NLP词的表示方法类型</a></li>
                
                    <li><a class="toctree-l4" href="#aone-hot-representation">A.One-hot Representation</a></li>
                
                    <li><a class="toctree-l4" href="#bdistributed-representation">B.Distributed Representation</a></li>
                
            
                <li class="toctree-l3"><a href="#3nlp">3.NLP语言模型</a></li>
                
            
                <li class="toctree-l3"><a href="#4">4.词的分布式表示</a></li>
                
                    <li><a class="toctree-l4" href="#a">A.基于矩阵的分布表示</a></li>
                
                    <li><a class="toctree-l4" href="#b">B.基于聚类的分布表示</a></li>
                
                    <li><a class="toctree-l4" href="#cword-embedding">C.基于神经网络的分布表示，词嵌入（word embedding）</a></li>
                
                    <li><a class="toctree-l4" href="#d">D.栗子</a></li>
                
            
                <li class="toctree-l3"><a href="#5word-embedding">5.词嵌入（word embedding）</a></li>
                
                    <li><a class="toctree-l4" href="#annlm">A.NNLM</a></li>
                
                    <li><a class="toctree-l4" href="#blbllog-linear-modelword2vec">B.LBL(log-linear model是基础也是word2vec的基础)</a></li>
                
            
                <li class="toctree-l3"><a href="#6">6.小结</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../chapter3/">word2vec</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../chapter4/">seq2seq</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../chapter5/">text2vec</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../about/">关于</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">NLP-2</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Embadding</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/DataXujing/nlp2/" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="1nlprepresentation">1.NLP的核心关键：语言表示（Representation）</h2>
<p>词向量、word embedding、分布式表示、word2vec、glove等等，这一锅粥的名词术语分别代表什么，他们具体的关系是什么，他们是否处于平级关系？</p>
<p>如何让Model在NLP中发挥真正的作用，先不提如何设计出很强势的网络结构，不提如何在NLP中引入基于DNN的解决例如情感分析、实体识别、机器翻译、文本生成这些高级任务，首先得把语言表示这一关过了——如何让语言表示成为DNN能够处理的数据类型。</p>
<p>在语音中，用音频频谱序列向量所构成的matrix作为前端输入喂给NN进行处理; 在图像中，用图片的像素构成的matrix展平成vector后组成的vector序列喂给DNN进行处理；
那在自然语言处理中呢？(TF, IDF, TF-IDF......)</p>
<p>语言作为人类在进化了几百万年所产生的一种高层的抽象的思维信息表达的工具，其具有高度抽象的特征，文本是符号数据，两个词只要字面不同，就难以刻画它们之间的联系，即使是“麦克风”和“话筒”这样的同义词，从字面上也难以看出这两者意思相同（语义鸿沟现象），可能并不是简单地一加一那么简单就能表示出来，而判断两个词是否相似时，还需要更多的背景知识才能做出回答。</p>
<p>这就回到了本节的主题：如何把高度抽象的语言转化为结构化的数据</p>
<hr />
<h2 id="2nlp">2.NLP词的表示方法类型</h2>
<p>词的表示方法主要分为两类：</p>
<ul>
<li>
<p>one-hot</p>
</li>
<li>
<p>distributed</p>
</li>
</ul>
<h3 id="aone-hot-representation">A.One-hot Representation</h3>
<pre><code class="python">“话筒”表示为 [0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 ...]
“麦克”表示为 [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ...]
</code></pre>

<p>优点：</p>
<ul>
<li>
<p>简单</p>
</li>
<li>
<p>简洁的表示方法配合上最大熵、SVM、CRF 等等算法已经很好地完成了 NLP 领域的各种主流任务</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>
<p>稀疏的</p>
</li>
<li>
<p>向量的维度会随着句子的词的数量类型增大而增大</p>
</li>
<li>
<p>任意两个词之间都是孤立的，根本无法表示出在语义层面上词语词之间的相关信息</p>
</li>
</ul>
<h3 id="bdistributed-representation">B.Distributed Representation</h3>
<ul>
<li>
<p>目的：解决One-hot的问题</p>
</li>
<li>
<p>Harris 在 1954 年提出的分布假说（ distributional hypothesis）为这一设想提供了理论基础：上下文相似的词，其语义也相似。</p>
</li>
<li>
<p>Firth 在 1957 年对分布假说进行了进一步阐述和明确：词的语义由其上下文决定（ a word is characterized by thecompany it keeps）。</p>
</li>
</ul>
<p>到目前为止，基于分布假说的词表示方法，根据建模的不同，主要可以分为三类：基于矩阵的分布表示、基于聚类的分布表示和基于神经网络的分布表示。尽管这些不同的分布表示方法使用了不同的技术手段获取词表示，但由于这些方法均基于分布假说，它们的核心思想也都由两部分组成：一、选择一种方式描述上下文；二、选择一种模型刻画某个词（下文称“目标词”）与其上下文之间的关系。</p>
<hr />
<h2 id="3nlp">3.NLP语言模型</h2>
<p>语言模型：</p>
<ul>
<li>
<p>文法语言模型</p>
</li>
<li>
<p>统计语言模型</p>
</li>
</ul>
<p>语言模型判定一句话是否为自然语言。机器翻译、拼写纠错、音字转换、问答系统、语音识别等应用在得到若干候选之后，然后利用语言模型挑一个尽量靠谱的结果。 </p>
<p>n元语言模型：对语料中一段长度为n 的序列wn−i+1,...,wi−1，即长度小于n的上文，n元语言模型需要最大化如下似然：</p>
<div align=center>
<img src="/img/5.png" />
</div>

<p>wi为语言模型要预测的目标词，序列wn−i+1,...,wi−1为模型的输入，即上下文，输出则为目标词wi的分布。用频率估计估计n元条件概率： </p>
<div align=center>
<img src="/img/5.1.png" />
</div>

<p>通常，n越大，越能保留词序信息，但是长序列出现的次数会非常少，导致数据稀疏的问题。一般三元模型较为常用。</p>
<div align=center>
<img src="/img/5.2.png" />
</div>

<p>具体的语言模型详情属于街货，详细请自行搜索。</p>
<hr />
<h2 id="4">4.词的分布式表示</h2>
<h3 id="a">A.基于矩阵的分布表示</h3>
<p>这类方法需要构建一个“词-上下文”矩阵，从矩阵中获取词的表示。在“词-上下文”矩阵中，每行对应一个词，每列表示一种不同的上下文，矩阵中的每个元素对应相关词和上下文的共现次数。
在这种表示下，矩阵中的一行，就成为了对应词的表示，这种表示描述了该词的上下文的分布。由于分布假说认为上下文相似的词，其语义也相似，因此在这种表示下，两个词的语义相似度可以直接转化为两个向量的空间距离。</p>
<p>该方法分为三个步骤：</p>
<ul>
<li>
<p>选取上下文。第一种：将词所在的文档作为上下文，形成“词-文档”矩阵（Syntagmatic Relation
）。第二种：将词附近上下文中的各个词（如上下文窗口中的5个词）作为上下文（Paradigmatic Relation
），形成“词-词”矩阵。第三种：将词附近上下文各词组成的n-gram作为上下文，形成“词-n元词组”。</p>
</li>
<li>
<p>确定矩阵中各元素的值。根据“词-上下文”共现矩阵的定义，里面各元素的值应为词与对应的上下文的共现次数。但一般采用多种加权和平滑方法，eg：tf-idf。</p>
</li>
<li>
<p>矩阵分解。常见分解技术：奇异值分解SVD、非负矩阵分解NMF、主成分分析PCA（另外，矩阵的维度较高并且非常稀疏，可以通过SVD、NMF等手段进行分解降维，变为低维稠密矩阵。 
经典模型代表：Global Vector模型（GloVe））。</p>
</li>
</ul>
<p>常见到的Global Vector 模型（GloVe模型）是一种对“词-词”矩阵进行分解从而得到词表示的方法，属于基于矩阵的分布表示。</p>
<h3 id="b">B.基于聚类的分布表示</h3>
<p>该方法以根据两个词的公共类别判断这两个词的语义相似度。最经典的方法是布朗聚类（Brown clustering)</p>
<h3 id="cword-embedding">C.基于神经网络的分布表示，词嵌入（word embedding）</h3>
<p>基于神经网络的分布表示一般称为词向量、词嵌入（word embedding）或分布式表示（distributed representation）。 </p>
<p>神经网络词向量表示技术通过神经网络技术对上下文，以及上下文与目标词之间的关系进行建模。由于神经网络较为灵活，这类方法的最大优势在于可以表示复杂的上下文。在前面基于矩阵的分布表示方法中，最常用的上下文是词。如果使用包含词序信息的 n-gram 作为上下文，当 n 增加时， n-gram 的总数会呈指数级增长，此时会遇到维数灾难问题。而神经网络在表示 n-gram 时，可以通过一些组合方式对 n 个词进行组合，参数个数仅以线性速度增长。有了这一优势，神经网络模型可以对更复杂的上下文进行建模，在词向量中包含更丰富的语义信息。</p>
<h3 id="d">D.栗子</h3>
<ul>
<li>‘词-文档‘矩阵</li>
</ul>
<div align=center>
<img src="/img/6.png" />
</div>

<ul>
<li>’词-词‘共现矩阵</li>
</ul>
<div align=center>
<img src="/img/7.png" />
</div>

<ul>
<li>
<p>矩阵分解</p>
</li>
<li>
<p>LSA</p>
</li>
</ul>
<div align=center>
<img src="/img/9.png" />
</div>

<ul>
<li>GloVe</li>
</ul>
<div align=center>
<img src="/img/10.png" />
</div>

<ul>
<li>思路</li>
</ul>
<div align=center>
<img src="/img/8.png" />
</div>

<hr />
<h2 id="5word-embedding">5.词嵌入（word embedding）</h2>
<p>基于神经网络的分布表示又称为词向量、词嵌入，神经网络词向量模型与其它分布表示方法一样，均基于分布假说，核心依然是上下文的表示以及上下文与目标词之间的关系的建模。</p>
<p>2001-2003年， Bengio 等人正式提出神经网络语言模型（ Neural Network Language Model ，NNLM），该模型在学习语言模型的同时，也得到了词向量。所以请注意一点：词向量可以认为是神经网络训练语言模型的副产品。</p>
<p>前面提过，one-hot表示法具有维度过大的缺点，那么现在将vector做一些改进：1、将vector每一个元素由整形改为浮点型，变为整个实数范围的表示；2、将原来稀疏的巨大维度压缩嵌入到一个更小维度的空间。如图示：</p>
<div align=center>
<img src="/img/11.png" />
</div>

<p><strong>词向量又名词嵌入的缘由</strong></p>
<p>关于基于神经网络的分布表示在近15年的发展中有太多太多的模型了，但是我们只要弄清楚了其中有代表性的几个，其他模型的学习和研究其应用场景就灰常灰常容易了。</p>
<p>本教程主要讲解四个Model, 其中后两个是Word2vec将在下一章节详细讲解</p>
<ul>
<li>
<p>NNLM</p>
</li>
<li>
<p>LBL</p>
</li>
<li>
<p>CBOW</p>
</li>
<li>
<p>Skip-Gram</p>
</li>
</ul>
<hr />
<h3 id="annlm">A.NNLM</h3>
<p>Neural Network Language Model [Y.Bengio et al. 2003]</p>
<p>Bengio 神经网络语言模型（Neural Network Language Model ，NNLM）是对 n 元语言模型进行建模，估算 P(wi|wn−i+1,...,wi−1) 的概率值。与n-gram等模型区别在于：NNLM不用记数的方法来估算 n 元条件概率，而是使用一个三层的神经网络模型（前馈神经网络），根据上下文的表示以及上下文与目标词之间的关系进行建模求解，如下图： </p>
<div align=center>
<img src="/img/12.png" />
</div>

<div align=center>
<img src="/img/13.png" />
</div>

<div align=center>
<img src="/img/14.png" />
</div>

<ul>
<li>说了这么多，副产品哪去了？</li>
</ul>
<p>一般神经网络的输入层仅仅是一个输入数据，而在这里，输入层x也是一个参数(存在C中)，也是需要优化的，优化之后词向量有了，
语言模型也有了。</p>
<h3 id="blbllog-linear-modelword2vec">B.LBL(log-linear model是基础也是word2vec的基础)</h3>
<p>Log-bilinear Language Model[A. Mnih &amp; G. Hinton, 2007]</p>
<div align=center>
<img src="/img/15.png" />
</div>

<div align=center>
<img src="/img/16.png" />
</div>

<hr />
<h2 id="6">6.小结</h2>
<p>关于Embadding时什么，解决什么问题我们已经比较清楚了，如何应用就更简单了，我们在前期的NLP培训及Tensorflow和Keras培训中，都介绍了Embadding层，在此不再赘述，除了以上列举的两个典型模型外还有其他模型，套路相似，可自查学习。</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../chapter3/" class="btn btn-neutral float-right" title="word2vec"/>Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../chapter1/" class="btn btn-neutral" title="TF-IDF"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../chapter1/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../chapter3/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
